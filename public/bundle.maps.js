{
  "version": 3,
  "sources": [
    "../../../Users/berna/AppData/Roaming/npm/node_modules/browserify/node_modules/browser-pack/_prelude.js",
    "../node_modules/lodash.debounce/index.js",
    "events.js"
  ],
  "names": [],
  "mappings": "AAAA;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACzXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA",
  "file": "generated.js",
  "sourceRoot": "",
  "sourcesContent": [
    "(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()",
    "/**\n * lodash (Custom Build) <https://lodash.com/>\n * Build: `lodash modularize exports=\"npm\" -o ./`\n * Copyright jQuery Foundation and other contributors <https://jquery.org/>\n * Released under MIT license <https://lodash.com/license>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n */\n\n/** Used as the `TypeError` message for \"Functions\" methods. */\nvar FUNC_ERROR_TEXT = 'Expected a function';\n\n/** Used as references for various `Number` constants. */\nvar NAN = 0 / 0;\n\n/** `Object#toString` result references. */\nvar symbolTag = '[object Symbol]';\n\n/** Used to match leading and trailing whitespace. */\nvar reTrim = /^\\s+|\\s+$/g;\n\n/** Used to detect bad signed hexadecimal string values. */\nvar reIsBadHex = /^[-+]0x[0-9a-f]+$/i;\n\n/** Used to detect binary string values. */\nvar reIsBinary = /^0b[01]+$/i;\n\n/** Used to detect octal string values. */\nvar reIsOctal = /^0o[0-7]+$/i;\n\n/** Built-in method references without a dependency on `root`. */\nvar freeParseInt = parseInt;\n\n/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar objectToString = objectProto.toString;\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeMax = Math.max,\n    nativeMin = Math.min;\n\n/**\n * Gets the timestamp of the number of milliseconds that have elapsed since\n * the Unix epoch (1 January 1970 00:00:00 UTC).\n *\n * @static\n * @memberOf _\n * @since 2.4.0\n * @category Date\n * @returns {number} Returns the timestamp.\n * @example\n *\n * _.defer(function(stamp) {\n *   console.log(_.now() - stamp);\n * }, _.now());\n * // => Logs the number of milliseconds it took for the deferred invocation.\n */\nvar now = function() {\n  return root.Date.now();\n};\n\n/**\n * Creates a debounced function that delays invoking `func` until after `wait`\n * milliseconds have elapsed since the last time the debounced function was\n * invoked. The debounced function comes with a `cancel` method to cancel\n * delayed `func` invocations and a `flush` method to immediately invoke them.\n * Provide `options` to indicate whether `func` should be invoked on the\n * leading and/or trailing edge of the `wait` timeout. The `func` is invoked\n * with the last arguments provided to the debounced function. Subsequent\n * calls to the debounced function return the result of the last `func`\n * invocation.\n *\n * **Note:** If `leading` and `trailing` options are `true`, `func` is\n * invoked on the trailing edge of the timeout only if the debounced function\n * is invoked more than once during the `wait` timeout.\n *\n * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred\n * until to the next tick, similar to `setTimeout` with a timeout of `0`.\n *\n * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)\n * for details over the differences between `_.debounce` and `_.throttle`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Function\n * @param {Function} func The function to debounce.\n * @param {number} [wait=0] The number of milliseconds to delay.\n * @param {Object} [options={}] The options object.\n * @param {boolean} [options.leading=false]\n *  Specify invoking on the leading edge of the timeout.\n * @param {number} [options.maxWait]\n *  The maximum time `func` is allowed to be delayed before it's invoked.\n * @param {boolean} [options.trailing=true]\n *  Specify invoking on the trailing edge of the timeout.\n * @returns {Function} Returns the new debounced function.\n * @example\n *\n * // Avoid costly calculations while the window size is in flux.\n * jQuery(window).on('resize', _.debounce(calculateLayout, 150));\n *\n * // Invoke `sendMail` when clicked, debouncing subsequent calls.\n * jQuery(element).on('click', _.debounce(sendMail, 300, {\n *   'leading': true,\n *   'trailing': false\n * }));\n *\n * // Ensure `batchLog` is invoked once after 1 second of debounced calls.\n * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });\n * var source = new EventSource('/stream');\n * jQuery(source).on('message', debounced);\n *\n * // Cancel the trailing debounced invocation.\n * jQuery(window).on('popstate', debounced.cancel);\n */\nfunction debounce(func, wait, options) {\n  var lastArgs,\n      lastThis,\n      maxWait,\n      result,\n      timerId,\n      lastCallTime,\n      lastInvokeTime = 0,\n      leading = false,\n      maxing = false,\n      trailing = true;\n\n  if (typeof func != 'function') {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  wait = toNumber(wait) || 0;\n  if (isObject(options)) {\n    leading = !!options.leading;\n    maxing = 'maxWait' in options;\n    maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;\n    trailing = 'trailing' in options ? !!options.trailing : trailing;\n  }\n\n  function invokeFunc(time) {\n    var args = lastArgs,\n        thisArg = lastThis;\n\n    lastArgs = lastThis = undefined;\n    lastInvokeTime = time;\n    result = func.apply(thisArg, args);\n    return result;\n  }\n\n  function leadingEdge(time) {\n    // Reset any `maxWait` timer.\n    lastInvokeTime = time;\n    // Start the timer for the trailing edge.\n    timerId = setTimeout(timerExpired, wait);\n    // Invoke the leading edge.\n    return leading ? invokeFunc(time) : result;\n  }\n\n  function remainingWait(time) {\n    var timeSinceLastCall = time - lastCallTime,\n        timeSinceLastInvoke = time - lastInvokeTime,\n        result = wait - timeSinceLastCall;\n\n    return maxing ? nativeMin(result, maxWait - timeSinceLastInvoke) : result;\n  }\n\n  function shouldInvoke(time) {\n    var timeSinceLastCall = time - lastCallTime,\n        timeSinceLastInvoke = time - lastInvokeTime;\n\n    // Either this is the first call, activity has stopped and we're at the\n    // trailing edge, the system time has gone backwards and we're treating\n    // it as the trailing edge, or we've hit the `maxWait` limit.\n    return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||\n      (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));\n  }\n\n  function timerExpired() {\n    var time = now();\n    if (shouldInvoke(time)) {\n      return trailingEdge(time);\n    }\n    // Restart the timer.\n    timerId = setTimeout(timerExpired, remainingWait(time));\n  }\n\n  function trailingEdge(time) {\n    timerId = undefined;\n\n    // Only invoke if we have `lastArgs` which means `func` has been\n    // debounced at least once.\n    if (trailing && lastArgs) {\n      return invokeFunc(time);\n    }\n    lastArgs = lastThis = undefined;\n    return result;\n  }\n\n  function cancel() {\n    if (timerId !== undefined) {\n      clearTimeout(timerId);\n    }\n    lastInvokeTime = 0;\n    lastArgs = lastCallTime = lastThis = timerId = undefined;\n  }\n\n  function flush() {\n    return timerId === undefined ? result : trailingEdge(now());\n  }\n\n  function debounced() {\n    var time = now(),\n        isInvoking = shouldInvoke(time);\n\n    lastArgs = arguments;\n    lastThis = this;\n    lastCallTime = time;\n\n    if (isInvoking) {\n      if (timerId === undefined) {\n        return leadingEdge(lastCallTime);\n      }\n      if (maxing) {\n        // Handle invocations in a tight loop.\n        timerId = setTimeout(timerExpired, wait);\n        return invokeFunc(lastCallTime);\n      }\n    }\n    if (timerId === undefined) {\n      timerId = setTimeout(timerExpired, wait);\n    }\n    return result;\n  }\n  debounced.cancel = cancel;\n  debounced.flush = flush;\n  return debounced;\n}\n\n/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return !!value && (type == 'object' || type == 'function');\n}\n\n/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return !!value && typeof value == 'object';\n}\n\n/**\n * Checks if `value` is classified as a `Symbol` primitive or object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n * @example\n *\n * _.isSymbol(Symbol.iterator);\n * // => true\n *\n * _.isSymbol('abc');\n * // => false\n */\nfunction isSymbol(value) {\n  return typeof value == 'symbol' ||\n    (isObjectLike(value) && objectToString.call(value) == symbolTag);\n}\n\n/**\n * Converts `value` to a number.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to process.\n * @returns {number} Returns the number.\n * @example\n *\n * _.toNumber(3.2);\n * // => 3.2\n *\n * _.toNumber(Number.MIN_VALUE);\n * // => 5e-324\n *\n * _.toNumber(Infinity);\n * // => Infinity\n *\n * _.toNumber('3.2');\n * // => 3.2\n */\nfunction toNumber(value) {\n  if (typeof value == 'number') {\n    return value;\n  }\n  if (isSymbol(value)) {\n    return NAN;\n  }\n  if (isObject(value)) {\n    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;\n    value = isObject(other) ? (other + '') : other;\n  }\n  if (typeof value != 'string') {\n    return value === 0 ? value : +value;\n  }\n  value = value.replace(reTrim, '');\n  var isBinary = reIsBinary.test(value);\n  return (isBinary || reIsOctal.test(value))\n    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)\n    : (reIsBadHex.test(value) ? NAN : +value);\n}\n\nmodule.exports = debounce;\n",
    "const debounce = require(\"lodash.debounce\");\r\n\r\n// Control variables\r\nvar ghostNodeClick = false;\r\nvar ghostNodeHolder = null;\r\nvar mainModalOpen = false;\r\nconst debounceInterval = 500;\r\n\r\n// ---------------------------------------------\r\n//             authenticate client\r\n// ---------------------------------------------\r\nvar spotifyToken;\r\n\r\ngetSpotifyToken();\r\nasync function getSpotifyToken() {\r\n  spotifyToken = await fetch(\"/token\").then(function(res) {\r\n    return res.text();\r\n  });\r\n\r\n  spotifyGetParams = {\r\n    method: \"GET\",\r\n    headers: {\r\n      Authorization: \"Bearer \" + spotifyToken\r\n    },\r\n    mode: \"cors\",\r\n    cache: \"default\"\r\n  };\r\n}\r\n\r\n// ---------------------------------------------\r\n//             modal controls\r\n// ---------------------------------------------\r\n\r\nMicroModal.show(\"main-modal\");\r\n\r\nfunction showLoader() {\r\n  MicroModal.show(\"loading-modal\");\r\n}\r\nfunction closeLoader() {\r\n  MicroModal.close(\"loading-modal\");\r\n}\r\n\r\nconst onMainModalClose = function() {\r\n  mainModalOpen = false;\r\n  searchBar.value = \"\";\r\n};\r\n\r\nconst onMainModalShow = function() {\r\n  mainModalOpen = true;\r\n};\r\n\r\n// ---------------------------------------------\r\n//               document events\r\n// ---------------------------------------------\r\n\r\ndocument.onkeypress = function(e) {\r\n  e = e || window.event;\r\n  let charCode = typeof e.which == \"number\" ? e.which : e.keyCode;\r\n  if (charCode && !mainModalOpen) {\r\n    MicroModal.show(\"main-modal\", {\r\n      onClose: onMainModalClose,\r\n      onShow: onMainModalShow\r\n    });\r\n  }\r\n};\r\n\r\n// ---------------------------------------------\r\n//                autocomplete\r\n// ---------------------------------------------\r\n\r\n//Apply event listeners\r\nconst searchBar = document.getElementById(\"search-bar\");\r\nvar searchInput;\r\nautocomplete(searchBar);\r\n\r\nlet debouncedSearch = debounce(async function() {\r\n  if (searchInput != \"\") {\r\n    let artistList = await searchArtists(searchInput);\r\n\r\n    let acContainerElmnt = document.createElement(\"DIV\");\r\n    acContainerElmnt.setAttribute(\"id\", searchBar.id + \"autocomplete-list\");\r\n    acContainerElmnt.setAttribute(\"class\", \"autocomplete-items\");\r\n    document.getElementById(\"main-form\").appendChild(acContainerElmnt);\r\n\r\n    // construct list of artist search results\r\n    for (let i = 0; i < Object.keys(artistList).length; i++) {\r\n      let acItemElmnt = document.createElement(\"DIV\");\r\n      if (artistList[i].description) {\r\n        acItemElmnt.innerHTML =\r\n          artistList[i].name + \" - <i>\" + artistList[i].description + \"</i>\";\r\n      } else {\r\n        acItemElmnt.innerHTML = artistList[i].name;\r\n      }\r\n      acItemElmnt.innerHTML +=\r\n        \"<input type='hidden' value='\" +\r\n        artistList[i].name +\r\n        \"' data-artistid='\" +\r\n        artistList[i].id +\r\n        \"'>\";\r\n\r\n      // Creates 'add' button\r\n      let acAddBtnElmnt = document.createElement(\"button\");\r\n      acAddBtnElmnt.setAttribute(\r\n        \"class\",\r\n        \"btn btn-success btn-lg  autocomplete-btn\"\r\n      );\r\n      acAddBtnElmnt.innerHTML = \"+\";\r\n      acItemElmnt.appendChild(acAddBtnElmnt);\r\n      acAddBtnElmnt.addEventListener(\"click\", e => onClickAddItem(e)); // On 'add' button click\r\n      acItemElmnt.addEventListener(\"click\", e => onClickItem(e)); // On search item click\r\n      acContainerElmnt.appendChild(acItemElmnt);\r\n    }\r\n  }\r\n}, debounceInterval);\r\n\r\nfunction autocomplete(searchBar) {\r\n  let currentFocus;\r\n\r\n\r\n  // listen for user input in the search bar\r\n  searchBar.addEventListener(\"input\", function(e) {\r\n    searchInput = e.target.value;\r\n    currentFocus = -1;\r\n\r\n    closeAllLists();\r\n    let args = [{ searchInput: searchInput }];\r\n    debouncedSearch.bind(searchBar);\r\n    debouncedSearch();\r\n  });\r\n\r\n\r\n\r\n  /*execute a function presses a key on the keyboard:*/\r\n  searchBar.addEventListener(\"keydown\", function(e) {\r\n    // gets the list\r\n    let x = document.getElementById(this.id + \"autocomplete-list\");\r\n    // if we do have a list...\r\n    if (x) {\r\n      x = x.getElementsByTagName(\"div\");\r\n    }\r\n    if (e.keyCode == 40) {\r\n      /*If the arrow DOWN key is pressed, increase the currentFocus variable:*/\r\n      currentFocus++;\r\n      /*and and make the current item more visible:*/\r\n      addActive(x);\r\n    } else if (e.keyCode == 38) {\r\n      //up\r\n      /*If the arrow UP key is pressed,\r\n          decrease the currentFocus variable:*/\r\n      currentFocus--;\r\n      /*and and make the current item more visible:*/\r\n      addActive(x);\r\n    } else if (e.keyCode == 13) {\r\n      /*If the ENTER key is pressed, prevent the form from being submitted,*/\r\n      e.preventDefault();\r\n      if (currentFocus > -1) {\r\n        /*and simulate a click on the \"active\" item:*/\r\n        if (x) x[currentFocus].click();\r\n      }\r\n    }\r\n  });\r\n\r\n  function addActive(x) {\r\n    /*a function to classify an item as \"active\":*/\r\n    if (!x) return false;\r\n    /*start by removing the \"active\" class on all items:*/\r\n    removeActive(x);\r\n    if (currentFocus >= x.length) currentFocus = 0;\r\n    if (currentFocus < 0) currentFocus = x.length - 1;\r\n    /*add class \"autocomplete-active\":*/\r\n    x[currentFocus].classList.add(\"autocomplete-active\");\r\n  }\r\n  function removeActive(x) {\r\n    /*a function to remove the \"active\" class from all autocomplete items:*/\r\n    for (let i = 0; i < x.length; i++) {\r\n      x[i].classList.remove(\"autocomplete-active\");\r\n    }\r\n  }\r\n\r\n  /*execute a function when someone clicks in the document:*/\r\n  document.addEventListener(\"click\", function(e) {\r\n    closeAllLists(e.target);\r\n  });\r\n}\r\n\r\nasync function onClickItem(e) {\r\n  e.stopPropagation();\r\n  let artistId = e.target\r\n    .getElementsByTagName(\"input\")[0]\r\n    .getAttribute(\"data-artistid\");\r\n\r\n  MicroModal.close(\"main-modal\");\r\n\r\n  closeAllLists();\r\n  showLoader();\r\n\r\n  let resJSON = await getArtistInfo(artistId);\r\n\r\n  closeLoader();\r\n  clearNetwork();\r\n  startNetwork(resJSON);\r\n}\r\n\r\nfunction closeAllLists() {\r\n  let items = document.getElementsByClassName(\"autocomplete-items\");\r\n  for (let i = 0; i < items.length; i++) {\r\n    items[i].parentNode.removeChild(items[i]);\r\n  }\r\n}\r\n\r\nasync function onClickAddItem(e) {\r\n  e.stopPropagation();\r\n\r\n  closeAllLists();\r\n  MicroModal.close(\"main-modal\");\r\n\r\n  let clickedArtistId = e.target.parentNode\r\n    .getElementsByTagName(\"input\")[0]\r\n    .getAttribute(\"data-artistid\");\r\n  let clickedArtistName = e.target.parentNode.getElementsByTagName(\"input\")[0]\r\n    .value;\r\n\r\n  // If there is no network (first click user did was on add button)\r\n  if (network == null) {\r\n    // Loading animation\r\n    showLoader();\r\n\r\n    let artistData = await getArtistInfo(clickedArtistId);\r\n\r\n    closeLoader();\r\n    clearNetwork();\r\n    startNetwork(artistData);\r\n  } \r\n\r\n  // There is already a network, let's add a node to it\r\n  else {\r\n    // Search artist on spotify for image\r\n    let spotifySearch = await quickSearchSpotify(clickedArtistName);\r\n    let gnImg = 'notfound.jpg';\r\n    if (spotifySearch.artists.items.length > 0) {\r\n      let artistSpotifyId = spotifySearch.artists.items[0].id;\r\n      let artistInfo = await getSpotifyArtistInfo(artistSpotifyId);\r\n\r\n      if (artistInfo.images.length > 1) {\r\n        gnImg = artistInfo.images[0].url;\r\n      } \r\n    } \r\n\r\n    // Creates 'ghost node' that follows mouse movement\r\n    // The size of the node scales according to the current zoom (scale)\r\n    // of the network\r\n    ghostNodeHolder = document.createElement(\"img\");\r\n    ghostNodeHolder.setAttribute(\"id\", \"ghostNode\");\r\n    ghostNodeHolder.setAttribute(\"class\", \"ghost-node rounded-circle\");\r\n    ghostNodeHolder.setAttribute(\"width\", 320 * network.getScale());\r\n    ghostNodeHolder.setAttribute(\"height\", 320 * network.getScale());\r\n    ghostNodeHolder.src = gnImg;\r\n    ghostNodeHolder.setAttribute(\"data-artistId\", clickedArtistId);\r\n    document.body.appendChild(ghostNodeHolder);\r\n\r\n    document.body.addEventListener(\"mousemove\", e => {onGhostNodeMousemove(e)});\r\n  }\r\n}\r\n\r\n\r\nfunction onGhostNodeMousemove(e){\r\n  mouseX = e.clientX - bounds.left;\r\n  mouseY = e.clientY - bounds.top;\r\n\r\n  let nodeX = mouseX - parentNodeSize * network.getScale();\r\n  let nodeY = mouseY - parentNodeSize * network.getScale() + bounds.top;\r\n\r\n  ghostNodeHolder.style.left = nodeX + \"px\";\r\n  ghostNodeHolder.style.top = nodeY + \"px\";\r\n  let debounced_onGhostNodeClick = debounce(onGhostNodeClick(),debounceInterval);\r\n\r\n  ghostNodeHolder.addEventListener(\"click\",debounced_onGhostNodeClick());\r\n}\r\n\r\n\r\nasync function onGhostNodeClick(){\r\n  let clickedArtistId = ghostNodeHolder.getAttribute(\"data-artistId\");\r\n  let canvasCoords = network.DOMtoCanvas({ x: mouseX, y: mouseY });\r\n  console.log(\"TRIGGER\");\r\n  ghostNodeHolder.parentNode.removeChild(ghostNodeHolder);\r\n\r\n  showLoader();\r\n  let artistData = await getArtistInfo(clickedArtistId);\r\n  closeLoader();\r\n\r\n  createNode(artistData, canvasCoords.x, canvasCoords.y);\r\n\r\n}\r\n"
  ]
}